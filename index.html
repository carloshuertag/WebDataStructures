<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Data Structures</title>
  <link rel="stylesheet" href="style.css" />
  <script src="tools/utils.js" type="text/javascript"></script>
  <script src="tools/index.js" type="text/javascript"></script>
</head>

<body>
  <header>
    <section>
      <span id="title">Data Structures</span>
      <span id="darkMode">
        <label for="dark">Dark Mode<span class="buttonSpace"></span></label>
        <label class="switch">
          <input id="dark" type="checkbox" checked>
          <span class="slider round"></span>
        </label>
      </span>
    </section>
    <nav>
      <ul>
        <li id="aboutTab">About</li>
        <li id="stackTab">Stack</li>
        <li id="queueTab">Queue</li>
        <li id="listTab">List</li>
      </ul>
    </nav>
  </header>
  <main>
    <section id="about">
      <article>
        <h1>Description</h1>
        <p>Displays the stacks, queues and singly linked lists behavior.</p>
        <p>Powered by CSS, JS and HTML with no frameworks.</p>
        <h1>Authors:</h1>
        <h4>Esmeralda Godinez Montero</h4>
        <h4>Diego David Flores Nogueira</h4>
        <h4>Carlos Huerta Garc√≠a</h4>
      </article>
    </section>
    <section id="stack">
      <section class="dsGrid">
        <article id="sOptions">
          <button class="btn" id="newStack"><span><img src="icons/new.svg" /></span>New Stack</button>
          <span class="buttonSpace"></span>
          <button class="btn" id="saveStack"><img src="icons/save.svg" />Save Stack</button>
          <span class="buttonSpace"></span>
          <button class="btn" id="loadStack"><img src="icons/load.svg" />Load Stack</button>
          <br/><br/>
          <form>
            <label for="sElement">Element:</label>
            <input id="sElement" name="sElement" type="number" size="8" required />
            <span class="buttonSpace"></span>
            <button class="btn" type="button" id="push"><img src="icons/add.svg" />Push</button>
          </form>
          <br/>
          <button class="btn" id="pop"><img src="icons/remove.svg" />Pop</button>
        </article>
        <article id="sAnimation">
          <table>
            <thead>
              <tr>
                <th id="sHead">head</th>
              </tr>
            </thead>
            <tbody id="stackAnimation"></tbody>
            <tfoot>
              <tr>
                <td id="sTail">tail</td>
              </tr>
            </tfoot>
          </table>
        </article>
        <article id="sCode">
          #include &lt;stdlib.h&gt;<br/>
          #include &lt;limits.h&gt;<br/>
          #include &lt;stdio.h&gt;<br/><br/>
          typedef int StackEntry;<br/>
          typedef struct StackNode<br/>
          {<br/>
          &nbsp;&nbsp;StackEntry entry;<br/>
          &nbsp;&nbsp;struct StackNode *next;<br/>
          } StackNode;<br/>
          typedef struct Stack<br/>
          {<br/>
              StackNode *head;<br/>
              StackNode *tail;<br/>
          } Stack;<br/><br/>
          <article id="createStack">
            <span>Stack *createStack()</span><br/>
            {<br/>
            <span>&nbsp;&nbsp;Stack *stack = (Stack *)malloc(sizeof(Stack));</span><br/>
            <span>&nbsp;&nbsp;stack->head = stack->tail = NULL;</span><br/>
            <span>&nbsp;&nbsp;return stack;</span><br/>
            }<br/>
          </article><br/>
          <article id="createStackNode">
            <span>StackNode *createStackNode(StackEntry item)</span><br/>
            {<br/>
            <span>&nbsp;&nbsp;StackNode *node = (StackNode *)malloc(sizeof(StackNode));</span><br/>            
            <span>&nbsp;&nbsp;node->entry = item;</span><br/>
            <span>&nbsp;&nbsp;return node;</span><br/>
            }<br/>
          </article><br/>
          <article id="pushCode">
            <span>void push(StackEntry item, Stack *stack)</span><br/>
            {<br/>
            <span>&nbsp;&nbsp;StackNode *node = createStackNode(item);</span><br/>
            <span>&nbsp;&nbsp;if(!stack->head) </span><br/>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;stack->tail = node; //isEmpty</span>
            <span>&nbsp;&nbsp;node->next = stack->head;</span><br/>
            <span>&nbsp;&nbsp;stack->head = node;</span><br/>
            }<br/>
          </article><br />
          <article id="popCode">
            <span>&nbsp;&nbsp;StackEntry pop(Stack *stack)</span><br/>
            {<br/>
            <span>StackEntry popped = INT_MIN;</span><br/>
            <span>&nbsp;&nbsp;if (!stack->head) //isEmpty</span><br/>
            &nbsp;&nbsp;{<br/>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;perror("Error: current stack is empty");</span><br/>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;return popped;</span><br/>
            &nbsp;&nbsp;}<br/>
            <span>&nbsp;&nbsp;StackNode *temp = stack->head;</span><br/>
            <span>&nbsp;&nbsp;stack->head = stack->head->next;</span><br/>
            <span>&nbsp;&nbsp;popped = temp->entry;</span><br/>
            <span>&nbsp;&nbsp;free(temp);</span><br/>
            <span>&nbsp;&nbsp;return popped;</span><br/>
            }<br/>
          </article>
        </article>
      </section>
    </section>
    <section id="queue">
      <section class="dsGrid">
        <article id="qAnimation">
          <table>
            <tbody id="queueAnimation"></tbody>
          </table>
        </article>
        <article id="qOptions">
          <button class="btn" id="newQueue"><img src="icons/load.svg" />New Queue</button>
          <span class="buttonSpace"></span>
          <button class="btn" id="saveQueue"><img src="icons/save.svg" />Save Queue</button>
          <span class="buttonSpace"></span>
          <button class="btn" id="loadQueue"><img src="icons/load.svg" />Load Queue</button>
          <br /><br />
          <form>
            <label for="qElement">Element:</label>
            <input id="qElement" name="qElement" type="number" size="8" required />
            <span class="buttonSpace"></span>
            <button class = "btn" type="button" id="enqueue"><img src="icons/add.svg" />Enqueue</button>
          </form>
          <br/>
          <button class="btn" id="dequeue"><img src="icons/remove.svg" />Dequeue</button>
        </article>
        <article id="qCode">
          #include &lt;stdlib.h&gt;<br/>
          #include &lt;limits.h&gt;<br/>
          #include &lt;stdio.h&gt;<br/><br/>
          typedef int QueueEntry;<br/>
          typedef struct QueueNode<br/>
          {<br/> 
            &nbsp;&nbsp;QueueEntry entry;<br/>
            &nbsp;&nbsp;struct QueueNode *next;<br/>
          } QueueNode;<br/>
          typedef struct Queue<br/>
          {<br/>
            &nbsp;&nbsp;QueueNode *head;<br/>
            &nbsp;&nbsp;QueueNode *tail;<br/>
          } Queue;<br/><br/>
          <article id="createQueue">
              <span>Queue *createQueue()</span><br/>
              {<br/>
              <span>&nbsp;&nbsp;Queue *queue = (Queue *)malloc(sizeof(Queue));</span><br/>
              <span>&nbsp;&nbsp;queue->head = queue->tail = NULL;</span><br/>
              <span>&nbsp;&nbsp;return queue;</span><br/>
              }<br/>
          </article><br/>
          <article id="createQueueNode">
            <span>QueueNode *createQueueNode(QueueEntry item)</span><br/>
            {<br/>
            <span>&nbsp;&nbsp;QueueNode *node = (QueueNode *)malloc(sizeof(QueueNode));</span><br/>
            <span>&nbsp;&nbsp;node->entry = item;</span><br/>
            <span>&nbsp;&nbsp;return node;</span><br/>
            }<br/>
          </article><br/>
          <article id="enqueueCode">
            <span>void enqueue(QueueEntry item, Queue *queue)</span><br/>
            {<br/>
            <span>&nbsp;&nbsp;QueueNode *node = createQueueNode(item);</span><br/>
            <span>&nbsp;&nbsp;if((queue->head)==NULL) queue->head = queue->tail = node;</span><br/>
            <span>&nbsp;&nbsp;else {</span><br/>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;queue->tail->next = node;</span><br/>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;queue->tail = node;</span><br/>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;node->next = NULL;</span><br/>
            &nbsp;&nbsp;}<br/>
            }<br/>
          </article><br/>
          <article id="dequeueCode">
            <span>QueueEntry dequeue(Queue *queue)</span><br/>
            {<br/>
              <span>&nbsp;&nbsp;QueueEntry dequeued = INT_MIN;</span><br/>
              <span>&nbsp;&nbsp;if ((queue->head)==NULL){</span><br/>
                  <span>&nbsp;&nbsp;&nbsp;&nbsp;perror("Error: current queue is empty");</span><br/>
                  <span>&nbsp;&nbsp;&nbsp;&nbsp;return dequeued;</span><br/>
                &nbsp;&nbsp;}<br/>        
              <span>&nbsp;&nbsp;QueueNode *temp = queue->head;</span><br/>
              <span>&nbsp;&nbsp;queue->head = queue->head->next;</span><br/>
              <span>&nbsp;&nbsp;dequeued = temp->entry;</span><br/>
              <span>&nbsp;&nbsp;free(temp);</span><br/>
              <span>&nbsp;&nbsp;return dequeued;</span><br/>
            }<br/>
          </article>
        </article>
      </section>
    </section>
    <section id="list">
      <section class="dsGrid">
        <article id="lAnimation">
          <table>
            <tbody id="listAnimation"></tbody>
          </table>
        </article>
        <article id="lOptions">
          <button class="btn" id="newList"><span><img src="icons/new.svg" /></span>New List</button>
          <span class="buttonSpace"></span>
          <button class="btn" id="saveList"><img src="icons/save.svg" />Save List</button>
          <span class="buttonSpace"></span>
          <button class="btn" id="loadList"><img src="icons/load.svg" />Load List</button>
          <br/><br/>
          <form>
            <label for="lElement">Element:</label>
            <input id="lElement" name="lElement" type="number" size="8" required/>
            <span class="buttonSpace"></span>
            <div class="tooltip">
            <label for="lPosition">Position:</label>
            <input id="lPosition" name="lPosition" type="number" size="8" required/>
            <span class="tooltiptext">Nodes positions start at 0.</span>
            </div>
            <br/><br/>
            <button class="btn" type="button" id="insertAtStart"><img src="icons/add.svg"/>Insert at start</button>
            <span class="buttonSpace"></span>
            <button class="btn" type="button" id="insertAt"><img src="icons/add.svg"/>Insert at</button>
            <span class="buttonSpace"></span>
            <button class="btn" type="button" id="append"><img src="icons/add.svg"/>Append</button><br/><br>
            <button class="btn" type="button" id="deleteAtStart"><img src="icons/remove.svg"/>Delete at start</button>
            <span class="buttonSpace"></span>
            <button class="btn" type="button" id="deleteAt"><img src="icons/remove.svg"/>Delete at</button>
            <span class="buttonSpace"></span>
            <button class="btn" type="button" id="deleteAtEnd"><img src="icons/remove.svg"/>Delete at end</button>
          </form>
        </article>
        <article id="lCode">
          #include &lt;stdlib.h&gt;<br/>
          #include &lt;stdio.h&gt;<br/>
          typedef int ListEntry;<br/><br/>
          typedef struct ListNode<br/>
          {<br/>
              &nbsp;&nbsp;ListEntry entry;<br/>
              &nbsp;&nbsp;struct ListNode *next;<br/>
          } ListNode;<br/>
          typedef struct List<br/> 
          {<br/>
              &nbsp;&nbsp;ListNode *start;<br/>
              &nbsp;&nbsp;ListNode *end;<br/>
              &nbsp;&nbsp;int size;<br/>
          } List;<br/><br/>
          <article id="createList">
            <span>List *createList()</span><br/>
            {<br/>
              <span>&nbsp;&nbsp;List *list = (List *)malloc(sizeof(List));</span><br/>
              <span>&nbsp;&nbsp;list->start = list->end = NULL;</span><br/>
              <span>&nbsp;&nbsp;list->size = 0;</span><br/>
              <span>&nbsp;&nbsp;return list;</span><br/>
            }<br/>
          </article><br/>
          <article id="createListNode">
            <span>ListNode *createListNode(ListEntry item)</span><br/>
            {<br/>
              <span>&nbsp;&nbsp;ListNode *node = (ListNode *)malloc(sizeof(ListNode));</span><br/>
              <span>&nbsp;&nbsp;node->entry = item;</span><br/>
              <span>&nbsp;&nbsp;return node;</span><br/>
            }<br/>
          </article><br/>
          <article id="insertAtStartCode">
            <span>void insertAtStart(ListEntry item, List *list)</span><br/>
            {<br/>
                <span>&nbsp;&nbsp;ListNode *node = createListNode(item);</span><br/>
                <span>&nbsp;&nbsp;if(list->start == NULL) list->start = list->end = node;</span><br/>
                <span>&nbsp;&nbsp;else {</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;node->next = list->start;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->start = node;</span><br/>
                <span>}</span><br/>
                <span>&nbsp;&nbsp;list->size++;</span><br/>
            }<br/>
          </article><br/>
          <article id="insertAtCode">
            <span>void insertAt(ListEntry item, List *list, int position)</span><br/>
            {<br/>
                <span>&nbsp;&nbsp;if(0&lt;=position && position<list->size)</span><br/>
                    <span>&nbsp;&nbsp;if(position==0) insertAtStart(item, list);</span><br/>
                    <span>&nbsp;&nbsp;else {</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;ListNode *node = createListNode(item);</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;ListNode *previousNode = searchListNode(list, position-1);</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;ListNode *actualNode = previousNode->next;</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;previousNode->next = node;</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;node->next = actualNode;</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;list->size++;</span><br/>
                    <span>}</span><br/>
                <span>&nbsp;&nbsp;else perror("Error: invalid position");</span><br/>
            }<br/>
          </article><br/>
          <article id="searchListNode">
            <span>ListNode *searchListNode(List *list, int position)</span><br/>
            {<br/>
              <span>&nbsp;&nbsp;if(position==0) return list->start;</span><br/>
              <span>&nbsp;&nbsp;if(position==list->size-1) return list->end;</span><br/>
              <span>&nbsp;&nbsp;ListNode *aux = list->start;</span><br/>
              <span>&nbsp;&nbsp;while(position!=0) {</span><br/>
                  <span>&nbsp;&nbsp;&nbsp;&nbsp;aux = aux->next;</span><br/>
                  <span>&nbsp;&nbsp;&nbsp;&nbsp;position--;</span><br/>
              <span>&nbsp;&nbsp;}</span><br/>
              <span>&nbsp;&nbsp;return aux;</span><br/>
          }<br/> 
          </article><br/>
          <article id="appendCode">
            <span>void append(ListEntry item, List *list)</span><br/> 
            {<br/>
                <span>&nbsp;&nbsp;ListNode *node = createListNode(item);</span><br/>
                <span>&nbsp;&nbsp;if(list->start == NULL) list->start = list->end = node;</span><br/>
                <span>&nbsp;&nbsp;else {</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->end->next = node;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->end = node;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;node->next = NULL;</span><br/>
                <span>&nbsp;&nbsp;}</span><br/>
                <span>&nbsp;&nbsp;list->size++;</span><br/>
            }<br/>
          </article><br/>
          <article id="deleteAtStartCode">
            <span>void deleteAtStart(List *list)</span><br/>
            {<br/>
                <span>&nbsp;&nbsp;if ((list->beginning)==NULL) perror("Error: current queue is empty");</span><br/>
                <span>&nbsp;&nbsp;else {</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;ListNode *temp = list->start;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->start = list->start->next;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;free(temp);</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->size--;</span><br/>
                <span>&nbsp;&nbsp;}</span><br/>
            }<br/><br/>
          </article><br/>
          <article id="deleteAtCode">
            <span>void deleteAt(List *list, int position)</span><br/>
            {<br/>
                <span>&nbsp;&nbsp;if(0&lt;=position && position<list->size)</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;if(position==0) deleteAtStart(list);</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;else if(position==list->size-1) deleteAtEnd(list);</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;else {</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode *previousNode = searchListNode(list, position-1);</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode *temp = previousNode->next;</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previousNode->next = previousNode->next->next;</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(temp);</span><br/>
                        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list->size--;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;}</span><br/>
                <span>&nbsp;&nbsp;else perror("Error: invalid position");</span><br/>
            }<br/>
          </article><br/>
          <article id="deleteAtEndCode">
            <span>void deleteAtEnd(List *list)</span><br/>
            {<br/>
                <span>&nbsp;&nbsp;if ((list->end)==NULL) perror("Error: current queue is empty");</span><br/>
                <span>&nbsp;&nbsp;else {</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;ListNode *temp = list->end;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->end = searchListNode(list,(list->size) - 2);</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->end->next = NULL;</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;free(temp);</span><br/>
                    <span>&nbsp;&nbsp;&nbsp;&nbsp;list->size--;</span><br/>
                <span>&nbsp;&nbsp;}</span><br/>
            }<br/>
          </article><br/>
        </article>
      </section>
    </section>
  </main>
</body>
</html>